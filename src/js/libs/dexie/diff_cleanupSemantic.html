function diff_cleanupSemantic(diffs) {
  // Reduce the number of edits by eliminating semantically trivial equalities.
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var lastequality = null;  // Always equal to equalities[equalities.length-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities.push(pointer);
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null &amp;&amp; (lastequality.length &lt;= length_changes1) &amp;&amp;
          (lastequality.length &lt;= length_changes2)) {
        //alert('Splitting: "' + lastequality + '"');
        // Duplicate record
        diffs.splice(equalities[equalities.length - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalities.length - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalities.pop();
        // Throw away the previous equality (it needs to be reevaluated).
        equalities.pop();
        pointer = equalities.length ? equalities[equalities.length - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    diff_cleanupMerge(diffs);
  }
}